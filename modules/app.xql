xquery version "3.0";

module namespace app="http://localhost:8080/exist/apps/recipes/templates";


import module namespace xrest="http://exquery.org/ns/restxq/exist" at "java:org.exist.extensions.exquery.restxq.impl.xquery.exist.ExistRestXqModule";


import module namespace templates="http://exist-db.org/xquery/templates" ;
import module namespace config="http://localhost:8080/exist/apps/recipes/config" at "config.xqm";

declare namespace rest="http://exquery.org/ns/restxq";
declare namespace output="http://www.w3.org/2010/xslt-xquery-serialization";
declare namespace r="http://ns.datacraft.co.uk/recipe";

declare variable $app:data := $config:app-root || "/data/recipes";


(:~
 : List all recipes and return them as XML.
 :)
declare
    %rest:GET
    %rest:path("/recipes")
    %rest:produces("application/xml", "text/xml")
function app:all-recipes() {
    <r:recipes>
    {
        collection($app:data)/r:recipe
    }
    </r:recipes>
};


(:~
 : Retrieve a recipe identified by uuid.
 :)
declare 
    %rest:GET
    %rest:path("/recipes/{$id}")
function app:get-recipe($id as xs:string*) {
    collection($app:data)/r:recipe[r:id/text() = $id]
};

(:~
 : Search recipes using a given field and a (lucene) query string.
 :)
declare 
    %rest:GET
    %rest:path("/search-recipes")
    %rest:form-param("query", "{$query}", "")
    %rest:form-param("field", "{$field}", "ingredient")
function app:search-recipes($query as xs:string*, $field as xs:string*) {
    let $log := util:log("DEBUG", "Searching for '" || $query || "' in field '" || $field || "'" )
    return
    <r:recipes>
    {
        if ($query != "") then

            switch ($field)
                case "ingredient" return
(:                    collection($app:data)/r:recipe[ descendant::r:ingredient[ft:query(., $query)] ] :)
                    collection($app:data)/r:recipe[ngram:contains(descendant::r:ingredient, $query)] 

                case "title" return
(:                    collection($app:data)/r:recipe[ft:query(r:title, $query)]:)
                    collection($app:data)/r:recipe[ngram:contains(r:title, $query)]
                default return
(:                    collection($app:data)/r:recipe[ft:query(descendant::*, $query)]:)
                    collection($app:data)/r:recipe[ngram:contains(descendant::*, $query)] 
        else
            collection($app:data)/r:recipe
    }
    </r:recipes>
};

(:~
 : Update an existing address or store a new one. The address XML is read
 : from the request body.
 :)
declare
    %rest:PUT("{$content}")
    %rest:path("/recipe")
function app:create-or-edit-recipe($content as node()*) {
    let $id := ($content/r:recipe/r:id/text(), util:uuid())[1]
    let $data :=
        <r:recipe>
            <r:id>{$id}</r:id>
        { $content/r:recipe/*[not(self::r:id)] }
        </r:recipe>
    let $log := util:log("DEBUG", "Storing data into " || $app:data)
    let $stored := xmldb:store($app:data, $id || ".xml", $data)
    return
        app:all-recipes()
};

(:~
 : Delete an address identified by its uuid.
 :)
declare
    %rest:DELETE
    %rest:path("/recipe/{$id}")
function app:delete-recipe($id as xs:string*) {
    xmldb:remove($app:data, $id || ".xml"),
    app:all-recipes()
};


(:~
 : Reindex the recipe collection
 :)
declare
    %rest:GET
    %rest:path("/reindex-recipes")
    %rest:produces("application/xml", "text/xml")
function app:reindex-recipes() {
    let $login := xmldb:login($app:data, 'admin', '0verc00k')
    return 
    <reindex-status>
    {
        xmldb:reindex($app:data)
    }
    </reindex-status>
};



(:~
 : List resource functions from the restxq.registry
 :)
declare
    %rest:GET
    %rest:path("/restxq-functions")
    %rest:produces("application/xml", "text/xml")
function app:debug-restxq-registry() {
    rest:resource-functions()
};

(:~
 : get namespace URI
 
 DOESN'T WORK, name() and namespace-uri() return nothing
 :)
(:declare
    %rest:PUT("{$field}")
    %rest:path("/get-namespace")
function app:debug-get-namespace($field as node()*) {
        let $log := util:log("DEBUG", "Namespace of " || $field/name() || " is " || $field/namespace-uri() )
        return ()
};
:)

(:~
 : This is a sample templating function. It will be called by the templating module if
 : it encounters an HTML element with an attribute data-template="app:test" 
 : or class="app:test" (deprecated). The function has to take at least 2 default
 : parameters. Additional parameters will be mapped to matching request or session parameters.
 : 
 : @param $node the HTML node with the attribute which triggered this call
 : @param $model a map containing arbitrary data - used to pass information between template calls
 :)
declare function app:test($node as node(), $model as map(*)) {
    <p>Dummy TEST template output generated by function app:test at {current-dateTime()}. The templating
        function was triggered by the class attribute <code>class="app:test"</code>.</p>
};


(:xrest:register-module(xs:anyURI("app.xql")):)