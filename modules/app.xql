xquery version "3.0";

module namespace app="http://localhost:8080/exist/apps/recipes/templates";


import module namespace xrest="http://exquery.org/ns/restxq/exist" at "java:org.exist.extensions.exquery.restxq.impl.xquery.exist.ExistRestXqModule";


import module namespace templates="http://exist-db.org/xquery/templates" ;
import module namespace config="http://localhost:8080/exist/apps/recipes/config" at "config.xqm";

declare namespace rest="http://exquery.org/ns/restxq";
declare namespace output="http://www.w3.org/2010/xslt-xquery-serialization";
declare namespace r="http://ns.datacraft.co.uk/recipe";

declare variable $app:data := $config:app-root || "/data/recipes";


(:~
 : List all recipes and return them as XML.
 :)
declare
    %rest:GET
    %rest:path("/recipes")
    %rest:produces("application/xml", "text/xml")
function app:all-recipes() {
    <recipes>
    {
        for $recipe in collection($app:data)/recipe
        return
            $recipe
    }
    </recipes>
};


(:~
 : Retrieve a recipe identified by uuid.
 :)
declare 
    %rest:GET
    %rest:path("/recipes/{$id}")
function app:get-recipe($id as xs:string*) {
    collection($app:data)/recipe[id/text() = $id]
};

(:~
 : Search recipes using a given field and a (lucene) query string.
 :)
declare 
    %rest:GET
    %rest:path("/search")
    %rest:form-param("query", "{$query}", "")
    %rest:form-param("field", "{$field}", "name")
function app:search-recipes($query as xs:string*, $field as xs:string*) {
    <recipes>
    {
        if ($query != "") then
            switch ($field)
                case "ingredient" return
                    collection($app:data)/recipe[ngram:contains(ingredient, $query)]
                case "title" return
                    collection($app:data)/recipe[ngram:contains(title, $query)]
                default return
                    collection($app:data)/recipe[ngram:contains(., $query)]
        else
            collection($app:data)/recipe
    }
    </recipes>
};

(:~
 : Update an existing address or store a new one. The address XML is read
 : from the request body.
 :)
declare
    %rest:PUT("{$content}")
    %rest:path("/recipe")
function app:create-or-edit-recipe($content as node()*) {
    let $id := ($content/recipe/id/text(), util:uuid())[1]
    let $data :=
        <recipe>
            <id>{$id}</id>
        { $content/recipe/*[not(self::id)] }
        </recipe>
    let $log := util:log("DEBUG", "Storing data into " || $app:data)
    let $stored := xmldb:store($app:data, $id || ".xml", $data)
    return
        app:all-recipes()
};

(:~
 : Delete an address identified by its uuid.
 :)
declare
    %rest:DELETE
    %rest:path("/recipe/{$id}")
function app:delete-recipe($id as xs:string*) {
    xmldb:remove($app:data, $id || ".xml"),
    app:all-recipes()
};



(:~
 : This is a sample templating function. It will be called by the templating module if
 : it encounters an HTML element with an attribute data-template="app:test" 
 : or class="app:test" (deprecated). The function has to take at least 2 default
 : parameters. Additional parameters will be mapped to matching request or session parameters.
 : 
 : @param $node the HTML node with the attribute which triggered this call
 : @param $model a map containing arbitrary data - used to pass information between template calls
 :)
declare function app:test($node as node(), $model as map(*)) {
    <p>Dummy TEST template output generated by function app:test at {current-dateTime()}. The templating
        function was triggered by the class attribute <code>class="app:test"</code>.</p>
};


(:xrest:register-module(xs:anyURI("app.xql")):)